===
joq
===

A very simple scheduling system to manage parallel batch jobs.

Introduction
============

When running multiple batch jobs you are often faced with some problems.
For best performance, you would like to evenly distribute your jobs on the number of available CPUs. Yet, if you have more jobs than CPUs, some cpus would have to process more than one job. Yet, which jobs should share one CPU? If two jobs that would run for a long time when started in isolation happen to be submitted on the same CPU, they will take even longer. It would therefore be best to start only as many jobs as there are available CPUs and then start the next job as soon as one of the CPUs gets free. This is exactly what job scheduling systems (or batch queueing) like the sge of condor do. Yet, these systems are designed for *really large scale* computing. Jobs that run for days, weeks, months. Jobs that might be submitted by different users. Jobs that might not only be run on different CPUs but even on entirely different computers in a network. These systems are very powerful but they are also kind of involved to configure. joq is a very simple, single user, single computer version of these large scale schedulers. joq runs with hardly any configuration at all. joq is extremely simple, it comes in just a single file.

Getting started
===============

Make the file joq.py executable and put it somehwere in your path. Allow joq to manage your compute jobs, you have to start a joq server::

    joq -s -n 2

The server will essentially do nothing at this point. It is waiting for you to give further instructions. The server can run in the backgroud, but it will occasionally generate output. Normally, you won't need this output.

By starting the joq server with the option -n 2, we specify that joq can run a maximum of 2 parallel processes. It is always good to specify the number of parallel processes that you would like to run. The more parallel processes you have, the faster the jobs will be finished, yet if you have too many parallel processes (for example more than you have CPUs), you might not be making efficient use of your resources. Furthermore, it might be a good idea to keep at least one CPU free for your regular work.

To tell the server what to do, we have to interact with it. We do that by calling joq in client mode (that is without the -s argument) and giving an action specification.

submit
------

If you call joq as::

    joq submit "sleep 8" test.log

Then you will tell the joq server to run the command "sleep 8" as soon as a processing slot is free. Any output generated by this command will go the the file test.log. You can omit the logfile. Output will then go to /dev/null and you won't be able to see potential error messages. Thus, it is always a good idea to provide a logfile.

Note that the above command doesn't really do anything itself. It just tells the joq server to run the respective command as soon as possible (if you have a terminal open where you run the joq server, you can observe the server taking the job and preparing it for execution).

ls
--

To see what commands are currently running and what is currently in the waiting list, you can use the ls action::

    joq ls

This will give you a list of currently scheduled commands and tell you the commands that are currently running.

cancel
------

With the ls action, you can see the each job has a job id. You can use this id to cancel a running job::

    joq cancel <id>

This will cancel the respective job -- even if it already started running.

quit
----

If you call the quit action, you tell the server to shutdown and stop all processes that are currently running. This means that any jobs that might be running at the moment will be terminated.
